# 32.1 IM / 聊天室（从 0 到可上线）💬⚙️

> 真·工程落地教程：从协议设计、数据模型、消息投递、离线/重连、加密与风控，到监控运维与成本优化。目标不是“能跑一下”，而是**可灰度、可回滚、可观测、可扩展**的工业化 IM。🧪

---

## 0）产品与 SLO（先立下军令状）

- **消息投递（单房间）P50 ≤ 150ms，P99 ≤ 800ms**（同区域）。
- **可靠性**：服务可用性 ≥ 99.95%；单条消息**至少一次投递**，客户端通过幂等键实现“**看起来一次**”。
- **一致性**：**会话内强顺序**（per-conversation monotonic）；跨会话无全局顺序承诺。
- **容量**：单房间 1k 并发在线、群历史 ≥ 10^7 条。
- **安全**：传输全链路 TLS；可选 E2EE；违规内容可追溯（合规留存）。

---

## 1）系统总图（能跑、能长）

```
Client(Web/APP)
   │ WebSocket/SSE (Auth=JWT)
┌──▼──────────────┐
│  Realtime Gateway│───► Presence Service (Redis)
└──▲─────┬────────┘
   │     │fanout
   │     └────────► Notification Fanout (APNs/FCM)
   │
   ▼
Chat Service (Write path: validate → seq → store) 
   │  └─► Outbox
   │
   ├─► Event Bus (Kafka/NATS) ──►
   │        ├─ Indexer(Search/OpenSearch)
   │        ├─ Analytics/Stream ETL
   │        └─ Webhook/Integration
   │
   ├─► Storage (Postgres/Timescale)  ─ History API
   └─► Object Storage(S3/CDN/Image/AV pipeline)
```

- **Gateway**：WS 终端 → 房间路由、速率限制、心跳、断线续传点位。
- **Chat Service**：会话权限、**顺序号**分配、落库、**Outbox** 可靠投递。
- **Presence**：在线状态/打字中/最后活跃，走 Redis（TTL）。
- **Push**：离线设备 → APNs/FCM；静音/折叠策略。
- **搜索/分析**：从 EventBus 异步消费，不阻塞写路径。
- **媒体**：预签名直传 + 异步转码/缩略图；（可选）端侧加密。

---

## 2）消息协议（Envelope + 幂等）

### 2.1 WebSocket 基本帧（JSON or MsgPack）

```ts
// client → server
type C2S =
  | { t: 'auth', jwt: string }
  | { t: 'join', cid: string, since?: number }                // cid=conversation id, since=上次已收序号
  | { t: 'send', cid: string, mid: string, clientId: string, at: number, kind: 'text'|'image'|'sys', body: any }
  | { t: 'ack', cid: string, pos: number }                    // 已接收至序号 pos
  | { t: 'read', cid: string, pos: number }                   // 已读游标
  | { t: 'typing', cid: string, on: boolean };

// server → client
type S2C =
  | { t: 'ready', userId: string, serverTs: number }
  | { t: 'joined', cid: string, head: number }                // 当前会话头序号（最后一条）
  | { t: 'message', cid: string, seq: number, mid: string, from: string, at: number, kind: string, body: any }
  | { t: 'ack', cid: string, pos: number }                    // 服务端确认收到并入库
  | { t: 'read', cid: string, pos: number, from: string }
  | { t: 'typing', cid: string, from: string, on: boolean }
  | { t: 'error', code: string, msg: string };
```

- `mid`：客户端生成（**ULID/Snowflake**），用于幂等与去重。
- `seq`：**服务端分配的会话内单调递增序号**（强顺序保障）。
- `ack.pos`：按会话汇报“已收至X”，便于**断线补发**与**未读数**计算。

> **不做全局序号**，只做**每会话序号**，简化高可用。

---

## 3）存储模型（SQL 友好 & 可拆分）

### 3.1 表概念（Postgres/Prisma）

```prisma
model Conversation {
  id           String   @id @db.Uuid
  kind         String   // 'dm'|'group'|'channel'...
  createdAt    DateTime @default(now())
  lastSeq      BigInt   @default(0)        // 会话内序号头
  participants Participant[]
  messages     Message[]
}

model Participant {
  conversationId String
  userId         String
  role           String   // 'owner'|'member'|'admin'
  lastReadSeq    BigInt   @default(0)
  joinedAt       DateTime @default(now())
  @@id([conversationId, userId])
}

model Message {
  conversationId String
  seq            BigInt    // 主键包含 seq 实现会话内强顺序
  mid            String    // 客户端幂等 id (ULID)
  senderId       String
  kind           String    // 'text'|'image'|'file'|'sys'...
  body           Json      // 内容（E2EE: 存密文+元数据）
  at             DateTime  @default(now())
  edited         Boolean   @default(false)
  deleted        Boolean   @default(false)
  @@id([conversationId, seq])
  @@unique([conversationId, mid])         // 幂等
  @@index([conversationId, at])
}
```

- **写路径**：`SELECT lastSeq FOR UPDATE` → `seq = lastSeq+1` → `INSERT` → `UPDATE lastSeq`（或使用 `GENERATED BY SEQUENCE` per-cid）。
- **Outbox**（表或 log）：写消息同事务插入 outbox，后台可靠投递到 Kafka/NATS。

### 3.2 附加表

- `Receipt(message_id, user_id, state)`：送达/已读明细（可按会话聚合）。
- `Reaction(conversation_id, seq, emoji, user_id)`：消息表情。
- `Attachment(id, uri, mime, size, width, height, enc?)`：媒体元数据。
- `Blocklist(owner, blocked)`：拉黑关系。
- `Device(user_id, device_id, push_token, platform)`：推送路由。

---

## 4）发送 & 投递算法（强顺序 + 至少一次）

```ts
// 伪代码：send(message)
1. 校验 membership / 权限 / 速率
2. 幂等检查：若 (cid, mid) 已存在 → 直接返回存量记录（seq）
3. 事务内：
   3.1 获取会话序列号（for update）→ nextSeq
   3.2 插入 Message(cid, seq=nextSeq, mid, ...)
   3.3 更新 Conversation.lastSeq=nextSeq
   3.4 插入 Outbox(topic='delivered', key=cid, payload={seq,...})
4. Fanout：
   - 在线成员：Gateway 房间广播 `S2C.message`
   - 离线成员：记录未读，异步推 APNs/FCM（折叠 by cid）
5. 返回 `S2C.ack { pos: seq }` 给发送者
```

- **重复发送**：客户端掉线后重发同 `mid`，会命中 `@@unique` 幂等。
- **断线补发**：重连时 `join(cid, since=last_pos_from_client)` → 服务器**从 since+1 replay**。
- **未读数**：`max(0, lastSeq - participant.lastReadSeq)`；已读上报更新 `lastReadSeq` 并广播。

---

## 5）连接管理（重连、背压、降级）

- **心跳**：`ping/pong` 15s；若 `bufferedAmount` 超阈值（如 1MB），降速/丢旧（仅打字/正在输入这类非关键事件）。
- **重连**：指数退避 + 抖动（500ms → 1s → 2s → … ≤ 8s），带上**各会话 since** 批量补发。
- **降级**：WS 不可用 → **SSE 下行** + **HTTP 上行**（/send）；体验保底。
- **多设备**：每设备维护各自 `lastAckPos`；**已读聚合**取最大值广播。

客户端最小实现（TS）

```ts
class ChatWS {
  url: string; ws?: WebSocket; since = new Map<string, number>(); retry = 500;
  constructor(url: string) { this.url = url; }
  connect() {
    this.ws = new WebSocket(this.url);
    this.ws.onopen = () => { this.retry = 500; /* auth... join with since */ };
    this.ws.onmessage = (e) => this.onMsg(JSON.parse(e.data));
    this.ws.onclose = () => setTimeout(()=>this.connect(), Math.min(8000, this.retry*=2));
  }
  onMsg(m:any) {
    if (m.t==='message') {
      this.handleMessage(m);                 // render+store
      this.since.set(m.cid, m.seq);
    }
  }
  send(m:any) {
    if (!this.ws || this.ws.readyState!==1 || this.ws.bufferedAmount>1e6) return false;
    this.ws.send(JSON.stringify(m)); return true;
  }
}
```

---

## 6）媒体与大对象（省钱又稳）

- **直传**：客户端向后端申请 **预签名 URL**，直传 S3/对象存储，成功后再发消息引用。
- **转码**：异步生成缩略图/多码率；音视频可上队列与无头 FFmpeg 集群。
- **CDN**：带鉴权（token/签名 URL）；**私有空间**配合临时签名。
- **E2EE 媒体**：端侧生成随机 `fileKey`（AES-GCM 256），对文件体加密再上传；消息里只存 `uri + iv + keyId`，**不存明文 key**（从会话密钥派生或包装后另通道发）。

---

## 7）安全：传输、存储与（可选）端到端加密

- **传输层**：全站 TLS；WebSocket WSS；JWT 短期（15–60min）+ 刷新。
- **权限**：会话 ACL（管理员、成员、禁言、拉黑）；服务端每条消息检查。
- **风控**：速率限制（IP/User/Room），黑词/辱骂检测（可异步标记与回收）。
- **E2EE 选型**：
  - **2 人私聊**：Signal Double Ratchet（libs: libsignal）。
  - **群聊**：基于群密钥（Megolm alike）或 MLS（Message Layer Security，前沿标准）。服务端只见密文与元数据。
  - **密钥轮转**：成员变更→换群密钥；历史访问按策略保留/失效。
  - **合规**：若需审计留存，可仅对**部分会话**开启 E2EE；或在企业场景由 KMS 托管密钥并强制审计（透明度要写进隐私策略）。

---

## 8）搜索与归档

- **写时异步索引**：消息落库→Outbox→消费者写入 OpenSearch/Meilisearch（倒排 + 高亮）。
- **按会话分片**：`index = chat-YYYYMM` 或 hash(cid)%N；冷热分层。
- **归档与 TTL**：群历史 > N 年自动冷冻到便宜存储；法律合规保留期可配置。

---

## 9）在线状态 & 正在输入（Presence）

- Redis `SETEX user:{id} online 1 TTL=30s`，心跳刷新；订阅 `PUB/SUB` 广播变化。
- Typing：WS 广播 `typing(on/off)`，**不持久化**，超时自动熄灭（3–5s）。

---

## 10）推送（APNs/FCM）

- 合并策略：同 cid 未读折叠为一条（badge + 文案“X 条新消息”）。
- 点击深链：直达会话并携带 since 参数拉取缺口。
- 免打扰：夜间静音、工作时段策略、@我/系统例外。

---

## 11）跨房间通信与群管理

- **入群邀请/审批**：系统消息 + 角色升级；服务端强校验。
- **@提及**：提取 mention → 单独表，推送可精准到人。
- **子线程/回复**：`threadRootSeq` 字段关联；前端 UI 抽屉式展示。
- **消息编辑/撤回**：保留审计线（edited/deleted+who）；撤回后广播占位内容“已撤回”。

---

## 12）观测、调参与成本

- **指标**：`ws_conn_active、msg_write_qps、msg_fanout_qps、p95_delivery_ms、reconnect_rate、redis_cmd_qps、kafka_lag、push_success_rate`。
- **日志采样**：错误 100%，成功 ≤ 1%；开启**按会话采样**以便追查。
- **容量规划**：Gateway 节点≈在线连接数/（2~5万）；Redis 哨兵或集群；PG 分片按 cid Hash；对象存储费用主因是流量（CDN 缓存率>90%为宜）。

---

## 13）风控与合规（别等上热搜才想起）

- **速率限制**：token bucket：每用户/每房间/每IP 三档。
- **垃圾消息**：内容指纹 + 相似度；频繁外链/可疑域名拦截。
- **举报/封禁**：存证（消息快照/上下文），支持临时禁言/永久封号。
- **合规**：GDPR/CCPA 数据导出与删除；**年龄门槛**；企业客户需要**审计导出**。

---

## 14）端到端代码骨架（可直接抄）

### 14.1 网关（Node + ws）

```ts
// gateway.ts
import { WebSocketServer, WebSocket } from 'ws';
import jwt from 'jsonwebtoken';
import Redis from 'ioredis';

type Client = WebSocket & { uid?: string, rooms: Set<string> };
const pub = new Redis(process.env.REDIS_URL!);
const sub = new Redis(process.env.REDIS_URL!);

const wss = new WebSocketServer({ port: 9001 });
const roomMembers = new Map<string, Set<Client>>();

wss.on('connection', (ws: Client, req) => {
  ws.rooms = new Set();
  // auth
  try {
    const token = new URL(req.url!, 'http://x').searchParams.get('token')!;
    const { uid } = jwt.verify(token, process.env.JWT_SECRET!) as any;
    ws.uid = String(uid);
  } catch { return ws.close(4401, 'unauthorized'); }

  ws.on('message', (raw) => handle(ws, raw.toString()));
  ws.on('close', () => leaveAll(ws));
});

async function handle(ws: Client, raw: string) {
  let m: any; try { m = JSON.parse(raw) } catch { return; }
  if (m.t==='join') {
    join(ws, m.cid);
    // 补发：转给 Chat Service 的 /sync 接口或 Redis Stream（略）
  } else if (m.t==='send') {
    // 透传到 Chat Service（HTTP/RPC）；这里仅演示发布
    await pub.publish(`room:${m.cid}`, JSON.stringify({ t: 'send', from: ws.uid, ...m }));
  } else if (m.t==='ack' || m.t==='read' || m.t==='typing') {
    await pub.publish(`room:${m.cid}`, JSON.stringify({ ...m, from: ws.uid }));
  }
}

function join(ws: Client, cid: string) {
  let set = roomMembers.get(cid); if (!set) roomMembers.set(cid, set = new Set());
  set.add(ws); ws.rooms.add(cid);
}
function leaveAll(ws: Client) { for (const cid of ws.rooms) roomMembers.get(cid)?.delete(ws); }

sub.psubscribe('room:*');
sub.on('pmessage', (_, channel, msg) => {
  const cid = channel.split(':')[1];
  const payload = msg;
  for (const c of roomMembers.get(cid) || []) {
    if (c.readyState === WebSocket.OPEN && c.bufferedAmount < 1e6) c.send(payload);
  }
});
```

> 生产：**鉴权放到 Chat Service**，Gateway 仅路由；广播用 Redis Stream/NATS；加**背压与断线指标**。

### 14.2 写路径（NestJS/Express 伪代码）

```ts
// POST /chat/send
// body: { cid, mid, kind, body }
async function send(req, res) {
  const uid = req.ctx.user.id;
  await db.tx(async (tx) => {
    await assertMember(tx, req.body.cid, uid);
    const seq = await nextSeq(tx, req.body.cid);           // SELECT ... FOR UPDATE
    await tx.insert('Message', { conversationId: req.body.cid, seq, mid: req.body.mid, senderId: uid, kind: req.body.kind, body: req.body.body });
    await tx.update('Conversation', { id: req.body.cid }, { lastSeq: seq });
    await tx.insert('Outbox', { topic: 'delivered', key: req.body.cid, payload: { cid:req.body.cid, seq }});
  });
  res.json({ ok: true });
}
```

---

## 15）测试矩阵（别让 bug 上线才暴露）

- **一致性**：乱序/重复/丢包下，客户端视图是否与服务器最终一致。
- **断网/弱网**：切 2G、丢包 10–30%、延迟 200–800ms。
- **高并发**：1k 并发发送，P99 投递与 fanout 监控。
- **容灾**：PG 主从切换、Redis 分片抖动、Kafka 反压。
- **回放**：对单会话生成 10^6 条合成消息，验证索引与归档性能。

---

## 16）Checklist（落地版）✅

- [ ] 会话内强顺序（seq）+ 客户端幂等 `mid`  
- [ ] Outbox + 事件总线，写路径不被下游拖慢  
- [ ] 断线续传（since/ack）+ 重连退避 + 背压  
- [ ] 直传媒体 + 预签名 + CDN + （可选）端侧加密  
- [ ] 已读/送达与未读数一致性定义清楚  
- [ ] 速率限制、拉黑、内容风控、审计留痕  
- [ ] 指标/日志/追踪齐全，可灰度 & 快速回滚  
- [ ] E2EE（可选）策略、密钥轮转与合规说明  
- [ ] 搜索/归档/TTL 与成本控制策略  

---

### 结语

IM 的难点不在“能不能把 A 的字发给 B”，而在**顺序、可靠、可观测、可演化**。把**序号+幂等**当信仰，把**断线补发**当日常，把**风控与隐私**当底线，你的聊天室就不是“玩具”，而是能扛事儿的**基础设施**。🚀
